
const express = require('express');
const Event = require('../models/Event');
const EventRegistration = require('../models/EventRegistration');
const authMiddleware = require('../middleware/auth');
const roleMiddleware = require('../middleware/validation');
const router = express.Router();

// ========================
// GET ALL EVENTS (with filtering)
// ========================
router.get('/', async (req, res) => {
  try {
    const {
      search,
      eventType,
      category,
      format,
      location,
      dateFrom,
      dateTo,
      aiCategory,
      status = 'published',
      page = 1,
      limit = 10,
      sortBy = 'startDate',
      sortOrder = 'asc'
    } = req.query;

    // Build filter object
    const filter = { status };
    
    if (eventType) filter.eventType = eventType;
    if (category) filter.category = category;
    if (format) filter.format = format;
    if (location) filter.location = { $regex: location, $options: 'i' };
    if (aiCategory) filter.aiCategory = aiCategory;
    if (dateFrom || dateTo) {
      filter.startDate = {};
      if (dateFrom) filter.startDate.$gte = new Date(dateFrom);
      if (dateTo) filter.startDate.$lte = new Date(dateTo);
    }
    
    // Text search
    if (search) {
      filter.$text = { $search: search };
    }

    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Build sort object
    const sortObj = {};
    sortObj[sortBy] = sortOrder === 'desc' ? -1 : 1;

    // Get events with organizer information
    const events = await Event.find(filter)
      .populate('organizer', 'companyName companyLogo companyDescription')
      .sort(sortObj)
      .skip(skip)
      .limit(parseInt(limit));

    // Get total count for pagination
    const totalEvents = await Event.countDocuments(filter);
    const totalPages = Math.ceil(totalEvents / parseInt(limit));

    res.json({
      events,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalEvents,
        hasNextPage: parseInt(page) < totalPages,
        hasPrevPage: parseInt(page) > 1
      }
    });

  } catch (err) {
    console.error('Get events error:', err);
    res.status(500).json({ msg: 'Server error getting events' });
  }
});

// ========================
// GET SINGLE EVENT
// ========================
router.get('/:id', async (req, res) => {
  try {
    const event = await Event.findById(req.params.id)
      .populate('organizer', 'companyName companyLogo companyDescription');

    if (!event) {
      return res.status(404).json({ msg: 'Event not found' });
    }

    // Check if user is registered for this event (if authenticated)
    let userRegistration = null;
    if (req.headers.authorization) {
      try {
        const userId = req.user?.id;
        if (userId) {
          userRegistration = await EventRegistration.findOne({
            event: req.params.id,
            attendee: userId
          });
        }
      } catch (err) {
        // Ignore auth errors for public event view
      }
    }

    res.json({ 
      event,
      userRegistration 
    });

  } catch (err) {
    console.error('Get event error:', err);
    res.status(500).json({ msg: 'Server error getting event' });
  }
});

// ========================
// CREATE EVENT (Company Only)
// ========================
router.post('/', authMiddleware, roleMiddleware('company'), async (req, res) => {
  try {
    const {
      title,
      description,
      eventType,
      category,
      format,
      startDate,
      endDate,
      startTime,
      endTime,
      location,
      address,
      virtualLink,
      maxAttendees,
      registrationDeadline,
      isFree,
      ticketPrice,
      requirements,
      requiredDocuments,
      speakers,
      agenda,
      tags,
      skillsRequired,
      bannerImage,
      galleryImages,
      contactEmail,
      contactPhone,
      allowWaitlist,
      requiresApproval,
      aiCategory,
      difficultyLevel
    } = req.body;

    // Validate required fields
    if (!title || !description || !eventType || !category || !format || 
        !startDate || !endDate || !startTime || !endTime || !location || !registrationDeadline) {
      return res.status(400).json({ msg: 'All required fields must be provided' });
    }

    // Validate dates
    const start = new Date(startDate);
    const end = new Date(endDate);
    const deadline = new Date(registrationDeadline);
    
    if (start >= end) {
      return res.status(400).json({ msg: 'End date must be after start date' });
    }
    
    if (deadline >= start) {
      return res.status(400).json({ msg: 'Registration deadline must be before event start date' });
    }

    // Create new event
    const newEvent = new Event({
      title,
      description,
      eventType,
      category,
      format,
      startDate: start,
      endDate: end,
      startTime,
      endTime,
      location,
      address,
      virtualLink,
      maxAttendees: maxAttendees || 100,
      registrationDeadline: deadline,
      isFree: isFree !== false,
      ticketPrice: ticketPrice || 0,
      requirements,
      requiredDocuments: requiredDocuments || [],
      speakers: speakers || [],
      agenda: agenda || [],
      tags: tags || [],
      skillsRequired: skillsRequired || [],
      bannerImage,
      galleryImages: galleryImages || [],
      contactEmail,
      contactPhone,
      organizer: req.user.id,
      allowWaitlist: allowWaitlist || false,
      requiresApproval: requiresApproval || false,
      aiCategory: aiCategory || 'Machine Learning',
      difficultyLevel: difficultyLevel || 'Intermediate',
      status: 'published'
    });

    await newEvent.save();
    
    // Populate organizer information
    await newEvent.populate('organizer', 'companyName companyLogo companyDescription');

    res.status(201).json({
      msg: 'Event created successfully',
      event: newEvent
    });

  } catch (err) {
    console.error('Create event error:', err);
    res.status(500).json({ msg: 'Server error creating event' });
  }
});

// ========================
// UPDATE EVENT (Company Only, Own Events)
// ========================
router.put('/:id', authMiddleware, roleMiddleware('company'), async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);

    if (!event) {
      return res.status(404).json({ msg: 'Event not found' });
    }

    // Check if user owns this event
    if (event.organizer.toString() !== req.user.id) {
      return res.status(403).json({ msg: 'Not authorized to update this event' });
    }

    const {
      title,
      description,
      eventType,
      category,
      format,
      startDate,
      endDate,
      startTime,
      endTime,
      location,
 virtualLink,
           address,
      maxAttendees,
      registrationDeadline,
      isFree,
      ticketPrice,
      requirements,
      requiredDocuments,
      speakers,
      agenda,
      tags,
      skillsRequired,
      bannerImage,
      galleryImages,
      contactEmail,
      contactPhone,
      status,
      allowWaitlist,
      requiresApproval,
      aiCategory,
      difficultyLevel
    } = req.body;

    // Update fields
    if (title) event.title = title;
    if (description) event.description = description;
    if (eventType) event.eventType = eventType;
    if (category) event.category = category;
    if (format) event.format = format;
    if (startDate) event.startDate = new Date(startDate);
    if (endDate) event.endDate = new Date(endDate);
    if (startTime) event.startTime = startTime;
    if (endTime) event.endTime = endTime;
    if (location) event.location = location;
    if (address !== undefined) event.address = address;
    if (virtualLink !== undefined) event.virtualLink = virtualLink;
    if (maxAttendees) event.maxAttendees = maxAttendees;
    if (registrationDeadline) event.registrationDeadline = new Date(registrationDeadline);
    if (isFree !== undefined) event.isFree = isFree;
    if (ticketPrice !== undefined) event.ticketPrice = ticketPrice;
    if (requirements !== undefined) event.requirements = requirements;
    if (requiredDocuments) event.requiredDocuments = requiredDocuments;
    if (speakers) event.speakers = speakers;
    if (agenda) event.agenda = agenda;
    if (tags) event.tags = tags;
    if (skillsRequired) event.skillsRequired = skillsRequired;
    if (bannerImage !== undefined) event.bannerImage = bannerImage;
    if (galleryImages) event.galleryImages = galleryImages;
    if (contactEmail !== undefined) event.contactEmail = contactEmail;
    if (contactPhone !== undefined) event.contactPhone = contactPhone;
    if (status) event.status = status;
    if (allowWaitlist !== undefined) event.allowWaitlist = allowWaitlist;
    if (requiresApproval !== undefined) event.requiresApproval = requiresApproval;
    if (aiCategory) event.aiCategory = aiCategory;
    if (difficultyLevel) event.difficultyLevel = difficultyLevel;

    await event.save();
    await event.populate('organizer', 'companyName companyLogo companyDescription');

    res.json({
      msg: 'Event updated successfully',
      event
    });

  } catch (err) {
    console.error('Update event error:', err);
    res.status(500).json({ msg: 'Server error updating event' });
  }
});

// ========================
// DELETE EVENT (Company Only, Own Events)
// ========================
router.delete('/:id', authMiddleware, roleMiddleware('company'), async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);

    if (!event) {
      return res.status(404).json({ msg: 'Event not found' });
    }

    // Check if user owns this event
    if (event.organizer.toString() !== req.user.id) {
      return res.status(403).json({ msg: 'Not authorized to delete this event' });
    }

    // Delete all registrations for this event
    await EventRegistration.deleteMany({ event: event._id });

    // Delete the event
    await Event.findByIdAndDelete(req.params.id);

    res.json({ msg: 'Event deleted successfully' });

  } catch (err) {
    console.error('Delete event error:', err);
    res.status(500).json({ msg: 'Server error deleting event' });
  }
});

// ========================
// GET COMPANY'S EVENTS (Company Only)
// ========================
router.get('/company/my-events', authMiddleware, roleMiddleware('company'), async (req, res) => {
  try {
    const events = await Event.find({ organizer: req.user.id })
      .sort({ startDate: -1 });

    res.json({ events });

  } catch (err) {
    console.error('Get company events error:', err);
    res.status(500).json({ msg: 'Server error getting company events' });
  }
});

// ========================
// GET EVENT STATISTICS (Company Only)
// ========================
router.get('/company/stats', authMiddleware, roleMiddleware('company'), async (req, res) => {
  try {
    const totalEvents = await Event.countDocuments({ organizer: req.user.id });
    const publishedEvents = await Event.countDocuments({ organizer: req.user.id, status: 'published' });
    const draftEvents = await Event.countDocuments({ organizer: req.user.id, status: 'draft' });
    
    // Total registrations across all company events
    const totalRegistrations = await EventRegistration.countDocuments({
      event: { $in: await Event.find({ organizer: req.user.id }).distinct('_id') }
    });

    // Recent registrations
    const recentRegistrations = await EventRegistration.countDocuments({
      event: { $in: await Event.find({ organizer: req.user.id }).distinct('_id') },
      registrationDate: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } // Last 7 days
    });

    res.json({
      totalEvents,
      publishedEvents,
      draftEvents,
      totalRegistrations,
      recentRegistrations
    });

  } catch (err) {
    console.error('Get event stats error:', err);
    res.status(500).json({ msg: 'Server error getting event statistics' });
  }
});

// ========================
// GET UPCOMING EVENTS (Public)
// ========================
router.get('/public/upcoming', async (req, res) => {
  try {
    const upcomingEvents = await Event.find({
      status: 'published',
      startDate: { $gte: new Date() }
    })
      .populate('organizer', 'companyName companyLogo')
      .sort({ startDate: 1 })
      .limit(10);

    res.json({ events: upcomingEvents });

  } catch (err) {
    console.error('Get upcoming events error:', err);
    res.status(500).json({ msg: 'Server error getting upcoming events' });
  }
});

// ========================
// SEARCH EVENTS (Public)
// ========================
router.get('/public/search', async (req, res) => {
  try {
    const { q, eventType, category, location, date } = req.query;
    
    const filter = { status: 'published' };
    
    if (q) {
      filter.$text = { $search: q };
    }
    if (eventType) filter.eventType = eventType;
    if (category) filter.category = category;
    if (location) filter.location = { $regex: location, $options: 'i' };
    if (date) {
      const searchDate = new Date(date);
      filter.startDate = {
        $gte: searchDate,
        $lt: new Date(searchDate.getTime() + 24 * 60 * 60 * 1000)
      };
    }

    const events = await Event.find(filter)
      .populate('organizer', 'companyName companyLogo')
      .sort({ startDate: 1 })
      .limit(20);

    res.json({ events });

  } catch (err) {
    console.error('Search events error:', err);
    res.status(500).json({ msg: 'Server error searching events' });
  }
});

module.exports = router;

